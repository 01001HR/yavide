# Contents
* [Framework](#framework)
* [Services](#services)
  * [Syntax highlighting](#syntax-highlighting)
  * [Indexing](#indexing)
  * [Auto-formatting](#auto-formatting)
  * [Project builder](#project-builder)
* [How to enable/disable service](#how-to-enabledisable-service)

# Framework
Naturally, one does not want to block the main UI thread and obstruct the user workflow while doing some lenghty operations. Lengthy operations are 
are quite ubiquitous in development environments and as a matter of fact a lot of processing has to be done in background with or without user awareness 
in order to bring the best experience. As `Vim` did not really have native support for asynchronous processing (only recently some async support has been added?), 
a custom solution had to been brought in.

Therefore, to ease the development and integration of any kind of lengthy operations this framework has been developed. In the context of this framework 
lenghty operations are encapsulated in units called `services`. Each [`service`](../core/services/yavide_service.py):
  * Has its own unique ID
  * Is dispatched to its own background process
  * Can be started and shut down on request
  * Can be triggered at any moment during its runtime
  * Can notify the main thread about its events and queue the actions to be executed on the UI side

To make the communication between the UI and background `services` seamless, [`YavideServer`](../core/server/yavide_server.py) on the server side and [`Y_Server...()` API](../core/.api.vimrc) 
on the client side is taking care of that. `YavideServer` is a thin proxy layer which controls and handles all the `services`.

Important aspect of this framework is that it provides a generic `service` development platform and enables `service` developer to fully focus on the 
implementation details of particular `service`. See existing `services` to see an example how implementation may look like.

# Services

## Syntax highlighting

Compared to the limited `Vim` syntax highlighting mechanism, this service brings more complete syntax highlighting including support for the following symbols:
* Namespaces
* Namespace aliases
* Classes
* Structures
* Enums
* Enum values
* Unions
* Local variables
* Class/struct/union data members
* Class/struct/union function members
* Functions
* Function parameters
* Template type parameters
* Template non type parameters
* Template template parameters
* Macro definitions
* Macro instantiations
* Typedefs
* Using directives
* Using declarations

Before | After
-------|--------
![Syntax highlighting before](https://raw.githubusercontent.com/wiki/JBakamovic/yavide/images/syntax_highlighting_before_clang.png) | ![Syntax highlighting after](https://raw.githubusercontent.com/wiki/JBakamovic/yavide/images/syntax_highlighting_after_clang.png)

Initially, syntax highlighting service was using `ctags` as a back-end for tokenizing the source code. However, `ctags`, being based on
heuristics and not being a full-featured C++ parser, was falling short in some cases and especially with modern C++ codebases. 

Now, `ctags` back-end has been replaced with `clang`-based one and that gives us much more complete and correct results. Not only that 
new back-end is going to be used for syntax highlighting only, but it can/will be reused for many other purposes. I.e. implementing other services 
such as class browsers, indexers, refactoring, fix-its, comments, etc.

In order to see the full effect of syntax highlighting one will need to have a colorscheme which supports additional highlight groups. Standard Vim 
colorschemes, if not modified, do **not** contain these. See [`this file`](../core/syntax/after/syntax/cpp/cpp_syntax_highlight.vim) for a list of new 
highlight groups which you will need to add to your colorscheme of choice should you want to make a full use of syntax highlighting service.

There is an [`example colorscheme`](https://github.com/JBakamovic/yaflandia) that I have made and which `Yavide` uses by default. One may have a look there to see how things might look like. 
Disclaimer: **I am really not good at colors so feel free contribute back.**

### Configuration

As we are now using a full C++ back-end, in order to get the best results, we need to feed it in with compiler flags which are actually used to compile that specific project.

As of now, user is able to provide those flags (as a whitespace separated list) through `g:project_compiler_args` variable which can be found at `.yavide_proj` 
(a file at project root directory; generated by `Yavide` upon creation of a new project). 

Future plan is to automate this step further requiring no user intervention (i.e. support for CMake/Makefile projects).

Example how configuration might look like is:

    let g:project_compiler_args = '-Ilib -Iinclude -DFEATURE_XX -DEFATURE_YY -Wall -Werror'

### Diagnostics

If you don't see what you expected, you should have a look at the log file generated by `Yavide` server (i.e. `/tmp/YAVIDE_server.log`). There will be entries related to the 
syntax highlighter which will give you a hint what went wrong (i.e. `libclang` diagnostics). Specifically, you should try to search for a pattern like this:

    [INFO] [clang_tokenizer.py:35] run(): Parsing error: <Diagnostic severity 4, location <SourceLocation file '<project_src_dir>/sleep.hh', line 28, column 10>, spelling "'core/future.hh' file not found">

### Vim quirks

For bigger files, **scrolling** will become really really *slow* if `cursorline` variable is set (in my env set by default). This is a very old and very annoying Vim issue which is even mentioned in `vim-help`. 
See `:help 'cursorline'` for more details. 

To circumvent this issue one might `set nocursorline` for big files (can be even scripted) or turn it off permanently by putting it in [`.editor.vimrc`](../core/.editor.vimrc) file.

## Indexing
TBD

`ctags` + `cscope` combination is used. Shall be replaced with `clang`-based approach. 

![Indexer in action](https://raw.githubusercontent.com/wiki/JBakamovic/yavide/images/indexer_in_action.gif)

## Auto-formatting
TBD

Create `.clang-format` config file in the project root directory. Auto-formatting is being triggered upon each `SaveFile` action. 
In future this will be a matter of configuration. Currently it is hard-coded in this way.

![Auto-formatter in action](https://raw.githubusercontent.com/wiki/JBakamovic/yavide/images/auto_formatter_in_action.gif)

## Project builder
TBD

Set `g:project_env_build_command` to the build command specific to the project. I.e. after loading/importing the project do the following:  
  * `let g:project_env_build_command='make all'`

Once this variable has been successfully set, one is able to use `YavideBuildRun` command or `F7` to trigger the build.
Upon completion `quickfix` window will be populated with build output where in case of any warnings/errors one is able
to jump to the given warning/error double-clicking/pressing-enter-key on the particular entry from the list. Once the project has 
been saved build command will be persisted in project settings and therefore re-loaded on the next project start-up.

Current progress of the build cannot be tracked directly from `Yavide` but one can use `tail -f /tmp/yavide<random_string>build` from the terminal. 
Possibility to stream the build directly on-the-fly to the `Yavide` environment (i.e. `quickfix` window) needs to be evaluated and will be considered.

![Building the project](https://raw.githubusercontent.com/wiki/JBakamovic/yavide/images/build_in_action.gif)

# How to enable/disable service

Set `enabled` property to 0 or 1 corresponding to the service which you want to enable/disable. Property can be found as
part of the `g:project_service_<service_name>` variable which is defined in `<yavide_install_dir>/core/.globals.vimrc`.

